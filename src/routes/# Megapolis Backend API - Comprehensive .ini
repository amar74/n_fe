# Megapolis Backend API - Comprehensive Documentation

**Generated:** October 10, 2025  
**Version:** 0.1.0  
**Tech Stack:** FastAPI, SQLAlchemy 2.0 (Async), PostgreSQL, Alembic, Pydantic v2

---

## Table of Contents

1. [Executive Summary](#executive-summary)
2. [API Statistics & Overview](#api-statistics--overview)
3. [Architecture & Code Structure](#architecture--code-structure)
4. [Code Quality Assessment](#code-quality-assessment)
5. [Scalability Analysis](#scalability-analysis)
6. [API Endpoints Reference](#api-endpoints-reference)
7. [Request Flow & Architecture Diagrams](#request-flow--architecture-diagrams)
8. [Database Schema](#database-schema)
9. [Authentication & Authorization](#authentication--authorization)
10. [Best Practices & Patterns](#best-practices--patterns)
11. [Recommendations](#recommendations)

---

## Executive Summary

The Megapolis Backend API is a **well-structured, production-ready FastAPI application** following modern Python async/await patterns. It implements a clean layered architecture with clear separation of concerns.

### Key Highlights

✅ **Total API Endpoints:** 42+  
✅ **Architecture:** Clean 4-layer architecture (Routes → Services → Models → Database)  
✅ **Code Quality:** High - consistent patterns, proper type hints, async throughout  
✅ **Scalability:** Good - async design, transaction management, ready for horizontal scaling  
✅ **Documentation:** Excellent - well-documented code, comprehensive README and Development.md  

### Technology Stack

| Component | Technology | Version |
|-----------|-----------|---------|
| Web Framework | FastAPI | 0.116.1 |
| Database ORM | SQLAlchemy | 2.0.32 (async) |
| Database | PostgreSQL | Latest (psycopg 3.2.1) |
| Migrations | Alembic | 1.13.2 |
| Validation | Pydantic | v2 |
| Logging | Loguru | 0.7.2 |
| Auth | JWT + Supabase | PyJWT 2.10.1 |
| ASGI Server | Uvicorn | 0.37.0 |
| Dependency Mgmt | Poetry | 2.x |

---

## API Statistics & Overview

### Module Breakdown

| Module | Routes | Models | Services | Schemas | Status |
|--------|--------|--------|----------|---------|--------|
| **Authentication** | 3 | 1 | 1 | 4 | ✅ Complete |
| **Organizations** | 6 | 1 | 1 | 9 | ✅ Complete |
| **Accounts** | 9 | 4 | 1 | 12 | ✅ Complete |
| **Account Notes** | 5 | 1 | 1 | 4 | ✅ Complete |
| **Account Documents** | 5 | 1 | 1 | 4 | ✅ Complete |
| **User Permissions** | 5 | 1 | 1 | 3 | ✅ Complete |
| **Admin** | 2 | - | 1 | 4 | ✅ Complete |
| **Scraper** | 1 | - | 1 | 2 | ✅ Complete |
| **Formbricks Integration** | 4 | 1 | 1 | 5 | ✅ Complete |
| **Invites** | 2 | 1 | Embedded | 4 | ✅ Complete |
| **TOTAL** | **42+** | **12** | **10** | **51** | |

### Endpoint Distribution by HTTP Method

```
GET     : 18 endpoints (Read operations)
POST    : 14 endpoints (Create operations)
PUT     : 6 endpoints  (Update operations)
DELETE  : 4 endpoints  (Delete operations)
```

### Database Tables

**Total Tables:** 12
- `users`
- `organizations`
- `accounts`
- `contacts`
- `address`
- `account_notes`
- `account_documents`
- `user_permission`
- `invites`
- `formbricks_projects`
- `export`
- Supporting tables for relationships

**Total Migrations:** 27 (well-tracked evolution)

---

## Architecture & Code Structure

### 1. Overall Architecture Pattern

The application follows a **clean 4-layer architecture**:

```
┌─────────────────────────────────────────────────┐
│              HTTP Requests                       │
└────────────────┬────────────────────────────────┘
                 │
┌────────────────▼────────────────────────────────┐
│  LAYER 1: Routes (Controllers)                   │
│  Location: app/routes/*.py                       │
│  Purpose: HTTP handling, request/response        │
│  • Thin controllers                              │
│  • Pydantic validation                           │
│  • Dependency injection (auth, permissions)      │
└────────────────┬────────────────────────────────┘
                 │
┌────────────────▼────────────────────────────────┐
│  LAYER 2: Services (Business Logic)              │
│  Location: app/services/*.py                     │
│  Purpose: Business rules, orchestration          │
│  • Complex validations                           │
│  • Multi-model operations                        │
│  • Error handling                                │
│  • Transaction coordination                      │
└────────────────┬────────────────────────────────┘
                 │
┌────────────────▼────────────────────────────────┐
│  LAYER 3: Models (Data Access)                   │
│  Location: app/models/*.py                       │
│  Purpose: Database operations, ORM               │
│  • SQLAlchemy models                             │
│  • Class methods for CRUD                        │
│  • Relationships                                 │
└────────────────┬────────────────────────────────┘
                 │
┌────────────────▼────────────────────────────────┐
│  LAYER 4: Database (PostgreSQL)                  │
│  • Async connection pool                         │
│  • Transaction middleware                        │
│  • Automatic rollback on errors                  │
└──────────────────────────────────────────────────┘
```

### 2. Directory Structure

```
megapolis-api/
├── app/
│   ├── main.py                 # FastAPI app initialization, CORS, middleware
│   ├── router.py               # Central router combining all routes
│   ├── environment.py          # Environment config with Infisical support
│   │
│   ├── db/
│   │   ├── base.py             # SQLAlchemy Base class
│   │   └── session.py          # Async engine, session factory, transaction mgmt
│   │
│   ├── dependencies/
│   │   ├── user_auth.py        # get_current_user dependency (JWT)
│   │   └── permissions.py      # Role & permission dependencies
│   │
│   ├── middlewares/
│   │   └── request_transaction.py  # Auto transaction per request
│   │
│   ├── models/                 # SQLAlchemy ORM models
│   │   ├── user.py             # User model with CRUD methods
│   │   ├── organization.py     # Multi-tenant organization model
│   │   ├── account.py          # Account/Client management
│   │   ├── contact.py          # Contact information
│   │   ├── address.py          # Address data
│   │   ├── account_note.py     # Notes for accounts
│   │   ├── account_document.py # Document attachments
│   │   ├── user_permission.py  # Fine-grained permissions
│   │   ├── invite.py           # User invitations
│   │   └── formbricks_projects.py  # Formbricks integration
│   │
│   ├── routes/                 # API endpoints (controllers)
│   │   ├── auth.py             # Authentication (3 endpoints)
│   │   ├── organization.py     # Organization CRUD (6 endpoints)
│   │   ├── account.py          # Account management (9 endpoints)
│   │   ├── account_note.py     # Account notes (5 endpoints)
│   │   ├── account_document.py # Document management (5 endpoints)
│   │   ├── user_permission.py  # Permissions (5 endpoints)
│   │   ├── admin.py            # Super admin (2 endpoints)
│   │   ├── scraper.py          # Web scraping (1 endpoint)
│   │   ├── formbricks.py       # Survey integration (4 endpoints)
│   │   └── user.py             # User operations
│   │
│   ├── schemas/                # Pydantic models for validation
│   │   ├── auth.py             # Auth request/response schemas
│   │   ├── user.py             # User schemas
│   │   ├── organization.py     # Organization schemas
│   │   ├── account.py          # Account schemas (12 models)
│   │   ├── account_note.py     # Note schemas
│   │   ├── account_document.py # Document schemas
│   │   ├── user_permission.py  # Permission schemas
│   │   ├── admin.py            # Admin schemas
│   │   ├── scraper.py          # Scraper schemas
│   │   ├── formbricks.py       # Formbricks schemas
│   │   ├── invite.py           # Invite schemas
│   │   ├── contact.py          # Contact schemas
│   │   └── address.py          # Address schemas
│   │
│   ├── services/               # Business logic layer
│   │   ├── account.py          # Account business logic (577 lines)
│   │   ├── organization.py     # Organization logic (288 lines)
│   │   ├── user_permission.py  # Permission management (183 lines)
│   │   ├── account_document.py # Document operations (153 lines)
│   │   ├── account_note.py     # Note operations (132 lines)
│   │   ├── formbricks.py       # Formbricks integration (313 lines)
│   │   ├── admin.py            # Admin operations (77 lines)
│   │   ├── scraper.py          # Web scraping logic (102 lines)
│   │   ├── supabase.py         # Supabase integration (61 lines)
│   │   └── admin.py            # Super admin operations
│   │
│   └── utils/
│       ├── logger.py           # Loguru configuration
│       └── error.py            # Custom exception classes
│
├── alembic/
│   ├── env.py                  # Alembic async configuration
│   └── versions/               # 27 migration files
│
├── scripts/                    # Utility scripts
├── tests/                      # Test suite
├── manage.py                   # CLI for running/migrating
├── pyproject.toml              # Poetry dependencies
└── README.md                   # Comprehensive documentation
```

### 3. Key Architectural Patterns

#### 3.1 Request Transaction Pattern

**Every request gets an automatic transaction:**

```python
# app/middlewares/request_transaction.py
class RequestTransactionMiddleware(BaseHTTPMiddleware):
    async def dispatch(self, request: Request, call_next):
        session = AsyncSessionLocal()
        try:
            async with session.begin():
                # Bind session to request context
                token = _bind_request_transaction(session)
                response = await call_next(request)
                await session.commit()  # Auto-commit on success
                return response
        except Exception:
            await session.rollback()  # Auto-rollback on error
            raise
        finally:
            _reset_request_transaction(token)
            await session.close()
```

**Benefits:**
- ✅ Automatic transaction management
- ✅ No manual commit/rollback needed
- ✅ Guaranteed cleanup
- ✅ ACID compliance

#### 3.2 Dependency Injection Pattern

**Authentication:**

```python
# app/dependencies/user_auth.py
async def get_current_user(request: Request) -> User:
    auth_header = request.headers.get("Authorization")
    token = auth_header.replace("Bearer ", "")
    payload = jwt.decode(token, environment.JWT_SECRET_KEY, algorithms=["HS256"])
    user = await User.get_by_id(payload.get("sub"))
    return user
```

**Permission Checking:**

```python
# app/dependencies/permissions.py
def get_user_permission(required_permissions: Dict[str, List[str]]):
    async def permission_checker(current_user: User = Depends(get_current_user)):
        user_permission = await UserPermission.get_by_userid(current_user.id)
        # Check if user has required permissions
        for resource, required_actions in required_permissions.items():
            user_resource_permissions = getattr(user_permission, resource, [])
            missing_actions = [a for a in required_actions if a not in user_resource_permissions]
            if missing_actions:
                raise MegapolisHTTPException(status_code=403, ...)
        return UserPermissionResponse.model_validate(user_permission)
    return permission_checker
```

**Usage in Routes:**

```python
@router.post("/", response_model=AccountCreateResponse, status_code=201)
async def create_account_route(
    payload: AccountCreate,
    user: User = Depends(get_current_user),
    user_permission = Depends(get_user_permission({"accounts": ["view", "edit"]}))
):
    account = await create_account(payload, user)
    return AccountCreateResponse(account_id=str(account.account_id), ...)
```

#### 3.3 Model Layer Pattern

**Active Record-style with class methods:**

```python
# app/models/user.py
class User(Base):
    __tablename__ = "users"
    
    id: Mapped[uuid.UUID] = mapped_column(UUID(as_uuid=True), primary_key=True, ...)
    email: Mapped[str] = mapped_column(String(255), unique=True, index=True)
    org_id: Mapped[Optional[uuid.UUID]] = mapped_column(ForeignKey("organizations.id"))
    
    # Relationships
    organization: Mapped[Optional["Organization"]] = relationship("Organization", ...)
    
    @classmethod
    async def create(cls, email: str) -> "User":
        async with get_transaction() as db:
            user = cls(email=email, org_id=None, role=Roles.ADMIN)
            db.add(user)
            await db.flush()
            await db.refresh(user)
            return user
    
    @classmethod
    async def get_by_id(cls, user_id: int) -> Optional["User"]:
        async with get_transaction() as db:
            result = await db.execute(select(cls).where(cls.id == user_id))
            return result.scalar_one_or_none()
    
    @classmethod
    async def get_by_email(cls, email: str) -> Optional["User"]:
        async with get_transaction() as db:
            result = await db.execute(select(cls).where(cls.email == email))
            return result.scalar_one_or_none()
```

---

## Code Quality Assessment

### Score: **8.5/10** (Excellent)

### ✅ Strengths

#### 1. **Type Safety** (9/10)
- ✅ Comprehensive type hints throughout
- ✅ SQLAlchemy 2.0 `Mapped[]` types
- ✅ Pydantic v2 validation
- ✅ TYPE_CHECKING guards for circular imports

```python
# Excellent typing example
class Account(Base):
    account_id: Mapped[uuid.UUID] = mapped_column(UUID(as_uuid=True), ...)
    client_name: Mapped[str] = mapped_column(String(255), nullable=False)
    client_type: Mapped[ClientType] = mapped_column(Enum(ClientType), nullable=False)
    total_value: Mapped[Optional[float]] = mapped_column(Numeric)
```

#### 2. **Async/Await Consistency** (10/10)
- ✅ Fully async end-to-end
- ✅ No blocking I/O in request path
- ✅ Async database operations
- ✅ Async external API calls

```python
# All operations are async
async def create_account(payload: AccountCreate, current_user: User) -> Account:
    db = get_request_transaction()
    address = Address(**payload.client_address.model_dump())
    db.add(address)
    await db.flush()  # Async flush
    account = Account(...)
    db.add(account)
    await db.flush()
    await db.refresh(account)
    return account
```

#### 3. **Error Handling** (8/10)
- ✅ Custom exception class (`MegapolisHTTPException`)
- ✅ Structured error responses
- ✅ Global exception middleware
- ✅ Proper HTTP status codes

```python
class MegapolisHTTPException(HTTPException):
    def __init__(self, status_code: int, message: str = None, 
                 details: str = None, metadata: Optional[Dict] = None):
        self.status_code = status_code
        self.message = message or self._get_default_message(status_code)
        self.details = details or {}
        self.metadata = metadata or {}
        # ... structured error response
```

#### 4. **Logging** (9/10)
- ✅ Loguru throughout (no print statements)
- ✅ Structured logging
- ✅ Environment-aware (JSON in production)
- ✅ Log rotation and retention configured

```python
# Excellent logging setup
logger.add(
    sys.stdout,
    format="<green>{time:YYYY-MM-DD HH:mm:ss}</green> | <level>{level}</level> | ...",
    level="INFO",
    colorize=True,
    serialize=environment.ENVIRONMENT != "dev"  # JSON in production
)
```

#### 5. **Code Organization** (9/10)
- ✅ Clear separation of concerns
- ✅ One feature per module
- ✅ Consistent naming conventions
- ✅ Logical grouping

#### 6. **Guard Clauses & Early Returns** (9/10)
- ✅ Excellent use throughout services

```python
async def create_account(payload: AccountCreate, current_user: User) -> Account:
    # Guard clause - validate early
    if not current_user.org_id:
        logger.error(f"User {current_user.id} is not associated with any organization")
        raise MegapolisHTTPException(
            status_code=403,
            message="Access denied",
            details="User must be associated with an organization"
        )
    
    # Guard clause - check duplicates
    if len(all_emails) != len(set(all_emails)):
        raise MegapolisHTTPException(
            status_code=400,
            message="Validation error",
            details="Duplicate email addresses found"
        )
    
    # ... main logic after guards
```

#### 7. **Database Design** (8/10)
- ✅ Proper foreign keys and relationships
- ✅ Cascade delete configured
- ✅ Indexes on frequently queried columns
- ✅ Full-text search support
- ✅ UUID primary keys (good for distributed systems)

```python
# Well-designed relationships
class Account(Base):
    # Cascading deletes
    contacts: Mapped[List["Contact"]] = relationship(
        "Contact", 
        back_populates="account",
        foreign_keys="Contact.account_id",
        cascade="all, delete-orphan"  # Cascade delete
    )
    
    # Proper indexing
    account_id: Mapped[uuid.UUID] = mapped_column(
        UUID(as_uuid=True),
        primary_key=True,
        index=True,  # Indexed
        unique=True
    )
```

#### 8. **Advanced Features** (9/10)

**Full-Text Search:**
```python
# Advanced PostgreSQL full-text search in account service
ts_cfg = 'public.english_unaccent'
ts_query = func.plainto_tsquery(ts_cfg, q)

name_vec = func.to_tsvector(ts_cfg, func.coalesce(Account.client_name, ''))
name_rank = func.ts_rank_cd(name_vec, ts_query, 1)

# Weighted scoring
weighted_score = (
    (name_rank * 4.0) +      # Highest priority
    (email_rank * 3.0) +
    (website_rank * 2.0) +
    (address_rank * 1.0)
)
```

### ⚠️ Areas for Improvement

#### 1. **Test Coverage** (3/10)
- ❌ Minimal test coverage (only 2 test files)
- ❌ No integration tests visible
- ❌ No API endpoint tests

**Recommendation:** Add pytest-based test suite covering:
- Unit tests for services
- Integration tests for endpoints
- Database transaction tests
- Authentication/authorization tests

#### 2. **Input Validation** (7/10)
- ✅ Pydantic handles basic validation
- ⚠️ Some business rules in services (good)
- ⚠️ Could add more custom validators

**Example of needed validation:**
```python
# Current: Basic Pydantic validation
class AccountCreate(BaseModel):
    client_name: str  # No length validation
    company_website: Optional[HttpUrl]  # Good use of HttpUrl

# Recommended: Enhanced validation
class AccountCreate(BaseModel):
    client_name: str = Field(min_length=2, max_length=255)
    company_website: Optional[HttpUrl] = None
    
    @field_validator('client_name')
    def validate_client_name(cls, v):
        if not v.strip():
            raise ValueError("Client name cannot be empty or whitespace")
        return v.strip()
```

#### 3. **Documentation** (7/10)
- ✅ Excellent README and Development.md
- ✅ Good docstrings on routes
- ⚠️ Inconsistent docstrings in services/models
- ⚠️ Missing API versioning documentation

#### 4. **Configuration Management** (8/10)
- ✅ Centralized in `environment.py`
- ✅ Infisical integration for secrets
- ⚠️ Some hardcoded values in CORS middleware
- ⚠️ Could use Pydantic Settings more extensively

---

## Scalability Analysis

### Score: **8/10** (Very Good)

### ✅ Scalability Strengths

#### 1. **Async Architecture** (10/10)
- ✅ Fully async I/O (no blocking operations)
- ✅ Can handle thousands of concurrent connections
- ✅ Efficient resource utilization

**Benchmark estimate:**
- Single instance: ~5,000-10,000 req/s (simple endpoints)
- With database: ~1,000-2,000 req/s (complex queries)

#### 2. **Database Connection Pooling** (9/10)
```python
# Async engine with connection pooling
engine: AsyncEngine = create_async_engine(
    get_database_url(),
    echo=False,
    future=True,
    pool_pre_ping=True,  # Health checks
    pool_size=20,        # Default pool size
    max_overflow=40      # Can grow under load
)
```

#### 3. **Stateless Design** (10/10)
- ✅ JWT-based authentication (no server-side sessions)
- ✅ RESTful API design
- ✅ Can be horizontally scaled
- ✅ Load balancer ready

**Deployment topology:**
```
                    ┌─────────────┐
                    │Load Balancer│
                    └──────┬──────┘
                           │
         ┌─────────────────┼─────────────────┐
         │                 │                 │
    ┌────▼────┐       ┌────▼────┐       ┌────▼────┐
    │ API     │       │ API     │       │ API     │
    │Instance1│       │Instance2│       │Instance3│
    └────┬────┘       └────┬────┘       └────┬────┘
         │                 │                 │
         └─────────────────┼─────────────────┘
                           │
                    ┌──────▼──────┐
                    │  PostgreSQL │
                    │   (Primary) │
                    └─────────────┘
```

#### 4. **Multi-Tenancy Support** (9/10)
- ✅ Organization-based isolation
- ✅ `org_id` on all tenant-scoped tables
- ✅ Row-level security possible

```python
# All queries scoped by organization
async def list_accounts(..., current_user: User) -> List[Account]:
    # Automatic org scoping
    stmt = select(Account).where(Account.org_id == current_user.org_id)
```

#### 5. **Efficient Queries** (8/10)
- ✅ Eager loading with `selectinload` (prevents N+1 queries)
- ✅ Indexed columns
- ✅ Pagination support

```python
# Efficient eager loading
loader_options = (
    selectinload(Account.client_address),  # JOIN instead of N+1
    selectinload(Account.primary_contact),
    selectinload(Account.contacts),
)
stmt = select(Account).options(*loader_options)
```

### ⚠️ Scalability Concerns

#### 1. **No Caching Layer** (Medium Priority)
**Current:** Every request hits the database

**Recommendation:**
```python
# Add Redis for frequently accessed data
from redis import asyncio as aioredis

class CacheService:
    def __init__(self):
        self.redis = aioredis.from_url("redis://localhost")
    
    async def get_user(self, user_id: str):
        cached = await self.redis.get(f"user:{user_id}")
        if cached:
            return json.loads(cached)
        
        user = await User.get_by_id(user_id)
        await self.redis.setex(f"user:{user_id}", 300, json.dumps(user.to_dict()))
        return user
```

#### 2. **No Background Task Queue** (Medium Priority)
**Current:** All operations synchronous in request

**Use cases needing background tasks:**
- Email sending (invites)
- Web scraping
- Report generation
- Data exports

**Recommendation:**
```python
# Add Celery or ARQ for background tasks
from celery import Celery

celery_app = Celery('megapolis', broker='redis://localhost')

@celery_app.task
async def send_invite_email(invite_id: str):
    # Process async, outside request cycle
    ...

# In route:
@router.post("/invites")
async def create_invite(...):
    invite = await create_user_invite(...)
    send_invite_email.delay(str(invite.id))  # Background
    return invite
```

#### 3. **No Rate Limiting** (High Priority for Production)
**Current:** Unprotected endpoints

**Recommendation:**
```python
from slowapi import Limiter, _rate_limit_exceeded_handler
from slowapi.util import get_remote_address

limiter = Limiter(key_func=get_remote_address)
app.state.limiter = limiter

@router.post("/scraper/scrape")
@limiter.limit("10/minute")  # Rate limit
async def scrape_urls_endpoint(...):
    ...
```

#### 4. **Monitoring & Observability** (Medium Priority)
**Current:** Logging only

**Recommendation:**
- Add APM (Application Performance Monitoring): Sentry, DataDog, or New Relic
- Add metrics: Prometheus + Grafana
- Add distributed tracing: OpenTelemetry

---

## API Endpoints Reference

### Authentication (`/auth`)

| Method | Endpoint | Operation ID | Description | Auth Required |
|--------|----------|--------------|-------------|---------------|
| POST | `/auth/onsignup` | - | Handle user signup from Supabase | No |
| GET | `/auth/verify_supabase_token` | - | Exchange Supabase token for app JWT | No |
| GET | `/auth/me` | `getCurrentUser` | Get current authenticated user | Yes |

**Authentication Flow:**
```
1. User signs up/in with Supabase (frontend)
2. Frontend sends Supabase JWT to /auth/verify_supabase_token
3. Backend verifies with Supabase, creates/finds user in DB
4. Backend returns own JWT (30-day expiry)
5. Frontend uses this JWT for all subsequent requests
```

### Organizations (`/orgs`)

| Method | Endpoint | Operation ID | Description | Auth Required | Permissions |
|--------|----------|--------------|-------------|---------------|-------------|
| POST | `/orgs/create` | `createOrg` | Create new organization | Yes | - |
| GET | `/orgs/me` | `me` | Get user's organization | Yes | - |
| PUT | `/orgs/update/{org_id}` | `updateOrg` | Update organization | Yes | Admin |
| GET | `/orgs/members` | `getOrgMembers` | List organization members | Yes | - |
| POST | `/orgs/invites` | `createInvite` | Send user invite | Yes | Admin |
| POST | `/orgs/invites/accept` | `acceptInvite` | Accept invitation | Yes | - |

**Example Request:**
```bash
curl -X POST http://localhost:8000/orgs/create \
  -H "Authorization: Bearer YOUR_JWT_TOKEN" \
  -H "Content-Type: application/json" \
  -d '{
    "name": "Acme Corp",
    "website": "https://acme.com"
  }'
```

**Example Response:**
```json
{
  "message": "Organization created success",
  "org": {
    "id": "123e4567-e89b-12d3-a456-426614174000",
    "name": "Acme Corp",
    "owner_id": "user-uuid",
    "website": "https://acme.com",
    "created_at": "2025-10-10T12:00:00"
  }
}
```

### Accounts (`/accounts`)

**Core account management with full CRUD operations**

| Method | Endpoint | Operation ID | Description | Auth | Permissions |
|--------|----------|--------------|-------------|------|-------------|
| POST | `/accounts/` | `createAccount` | Create account with contacts | Yes | accounts: view, edit |
| GET | `/accounts/` | `listAccounts` | List accounts (paginated, searchable) | Yes | - |
| GET | `/accounts/{account_id}` | `getAccountById` | Get account details | Yes | - |
| PUT | `/accounts/{account_id}` | `updateAccount` | Update account | Yes | - |
| DELETE | `/accounts/{account_id}` | `deleteAccount` | Delete account | Yes | - |
| POST | `/accounts/{account_id}/contacts` | `addSecondaryContact` | Add secondary contact | Yes | - |
| GET | `/accounts/{account_id}/contacts` | `getAccountContacts` | List account contacts | Yes | - |
| PUT | `/accounts/{account_id}/contacts/{contact_id}` | `updateContact` | Update contact | Yes | - |
| DELETE | `/accounts/{account_id}/contacts/{contact_id}` | `deleteContact` | Delete contact | Yes | - |

**Search Features:**
- Full-text search across name, email, website, address
- Weighted ranking (name > email > website > address)
- Prefix matching support
- Tier filtering

**Example: Create Account**
```bash
curl -X POST http://localhost:8000/accounts/ \
  -H "Authorization: Bearer YOUR_JWT" \
  -H "Content-Type: application/json" \
  -d '{
    "client_name": "Tech Solutions Inc",
    "client_type": "tier_1",
    "market_sector": "Technology",
    "company_website": "https://techsolutions.com",
    "client_address": {
      "line1": "123 Main St",
      "line2": "Suite 100",
      "city": "San Francisco",
      "pincode": "94102"
    },
    "primary_contact": {
      "name": "John Doe",
      "email": "john@techsolutions.com",
      "phone": "+1-415-555-0123",
      "designation": "CEO"
    },
    "secondary_contacts": [
      {
        "name": "Jane Smith",
        "email": "jane@techsolutions.com",
        "phone": "+1-415-555-0124",
        "designation": "CTO"
      }
    ]
  }'
```

**Example: Search Accounts**
```bash
# Paginated search with filtering
GET /accounts/?page=1&size=10&search=Tech&tier=tier_1

Response:
{
  "accounts": [
    {
      "account_id": "uuid",
      "client_name": "Tech Solutions Inc",
      "client_type": "tier_1",
      "market_sector": "Technology",
      "total_value": 150000.0,
      "ai_health_score": 0.85,
      "last_contact": "2025-10-01T10:00:00",
      "primary_contact_name": "John Doe",
      "primary_contact_email": "john@techsolutions.com",
      "client_address": {
        "line1": "123 Main St",
        "city": "San Francisco",
        "pincode": "94102"
      }
    }
  ],
  "pagination": {
    "total": 1,
    "page": 1,
    "size": 10,
    "has_next": false,
    "has_prev": false
  }
}
```

### Account Notes (`/account_notes`)

| Method | Endpoint | Operation ID | Description |
|--------|----------|--------------|-------------|
| POST | `/account_notes/` | `createAccountNote` | Add note to account |
| GET | `/account_notes/` | `listAccountNotes` | List notes (filter by account) |
| GET | `/account_notes/{note_id}` | `getAccountNote` | Get specific note |
| PUT | `/account_notes/{note_id}` | `updateAccountNote` | Update note |
| DELETE | `/account_notes/{note_id}` | `deleteAccountNote` | Delete note |

### Account Documents (`/account_documents`)

| Method | Endpoint | Operation ID | Description |
|--------|----------|--------------|-------------|
| POST | `/account_documents/` | `createAccountDocument` | Upload document |
| GET | `/account_documents/` | `listAccountDocuments` | List documents |
| GET | `/account_documents/{document_id}` | `getAccountDocument` | Get document metadata |
| PUT | `/account_documents/{document_id}` | `updateAccountDocument` | Update document metadata |
| DELETE | `/account_documents/{document_id}` | `deleteAccountDocument` | Delete document |

### User Permissions (`/user_permissions`)

**Fine-grained permission management per user**

| Method | Endpoint | Operation ID | Description |
|--------|----------|--------------|-------------|
| POST | `/user_permissions/` | `createUserPermission` | Grant permissions to user |
| GET | `/user_permissions/{userid}` | `getUserPermission` | Get user's permissions |
| PUT | `/user_permissions/{userid}` | `updateUserPermission` | Update permissions |
| DELETE | `/user_permissions/{userid}` | `deleteUserPermission` | Revoke all permissions |
| GET | `/user_permissions/` | `listUserPermissions` | List all users with permissions |

**Permission Structure:**
```json
{
  "userid": "user-uuid",
  "accounts": ["view", "edit"],
  "opportunities": ["view"],
  "proposals": ["view", "edit"]
}
```

### Admin (`/admin`)

**Super admin operations**

| Method | Endpoint | Operation ID | Description | Access |
|--------|----------|--------------|-------------|--------|
| GET | `/admin/user_list` | `userList` | List all users (paginated) | Super Admin |
| POST | `/admin/create_new_user` | `createNewUser` | Create user with Supabase | Super Admin |

**Super Admin Check:**
- Role-based: `role == "super_admin"`, OR
- Email whitelist: `Constants.SUPER_ADMIN_EMAILS`

### Scraper (`/scraper`)

| Method | Endpoint | Operation ID | Description |
|--------|----------|--------------|-------------|
| POST | `/scraper/scrape` | `scrapeUrls` | Scrape contact info from URLs |

**Example:**
```bash
curl -X POST http://localhost:8000/scraper/scrape \
  -H "Authorization: Bearer YOUR_JWT" \
  -d '{
    "urls": [
      "https://example.com/contact",
      "https://another.com/about"
    ]
  }'

Response:
{
  "contacts": [
    {
      "url": "https://example.com/contact",
      "emails": ["info@example.com", "sales@example.com"],
      "phones": ["+1-555-1234"]
    }
  ],
  "successful_scrapes": 1,
  "failed_scrapes": 0
}
```

### Formbricks Integration (`/formbricks`)

**Survey/feedback integration**

| Method | Endpoint | Operation ID | Description |
|--------|----------|--------------|-------------|
| GET | `/formbricks/login-token` | `getFormbricksLoginToken` | Get SSO token for Formbricks |
| GET | `/formbricks/surveys` | `getFormbricksSurveys` | List organization surveys |
| POST | `/formbricks/surveys` | `createFormbricksSurvey` | Create new survey |
| POST | `/formbricks/surveys/{survey_id}/link` | `createFormbricksSurveyLink` | Generate survey link |

---

## Request Flow & Architecture Diagrams

### 1. Complete Request Flow

```
┌──────────────────────────────────────────────────────────────────┐
│  CLIENT (Frontend/Mobile)                                        │
│  - React/Next.js app                                             │
│  - Sends: Authorization: Bearer <JWT>                            │
└─────────────────────────┬────────────────────────────────────────┘
                          │ HTTP Request
                          ▼
┌──────────────────────────────────────────────────────────────────┐
│  ASGI SERVER (Uvicorn)                                           │
│  - Async HTTP server                                             │
│  - Connection pooling                                            │
└─────────────────────────┬────────────────────────────────────────┘
                          │
                          ▼
┌──────────────────────────────────────────────────────────────────┐
│  MIDDLEWARE STACK                                                │
│  ┌────────────────────────────────────────────────────────────┐ │
│  │ 1. CORS Middleware                                         │ │
│  │    - Origin validation                                     │ │
│  │    - Headers/Methods check                                 │ │
│  └────────────────────────────────────────────────────────────┘ │
│  ┌────────────────────────────────────────────────────────────┐ │
│  │ 2. RequestTransactionMiddleware ★                          │ │
│  │    - Create AsyncSession                                   │ │
│  │    - Start transaction: session.begin()                    │ │
│  │    - Bind to context var                                   │ │
│  │    - On success: commit                                    │ │
│  │    - On error: rollback                                    │ │
│  │    - Finally: cleanup                                      │ │
│  └────────────────────────────────────────────────────────────┘ │
│  ┌────────────────────────────────────────────────────────────┐ │
│  │ 3. Exception Handler                                       │ │
│  │    - Catch MegapolisHTTPException                          │ │
│  │    - Return structured JSON error                          │ │
│  │    - Log error with Loguru                                 │ │
│  └────────────────────────────────────────────────────────────┘ │
└─────────────────────────┬────────────────────────────────────────┘
                          │
                          ▼
┌──────────────────────────────────────────────────────────────────┐
│  FASTAPI ROUTER                                                  │
│  - Match path to endpoint                                        │
│  - Execute dependency injection                                  │
└─────────────────────────┬────────────────────────────────────────┘
                          │
                          ▼
┌──────────────────────────────────────────────────────────────────┐
│  DEPENDENCY INJECTION PHASE                                      │
│  ┌────────────────────────────────────────────────────────────┐ │
│  │ get_current_user()                                         │ │
│  │  1. Extract JWT from Authorization header                 │ │
│  │  2. Decode & verify JWT signature                         │ │
│  │  3. Extract user_id from payload                          │ │
│  │  4. Query database: User.get_by_id(user_id)               │ │
│  │  5. Return User object                                    │ │
│  └────────────────────────────────────────────────────────────┘ │
│  ┌────────────────────────────────────────────────────────────┐ │
│  │ get_user_permission(required_perms)                        │ │
│  │  1. Get user from get_current_user                        │ │
│  │  2. Check if org owner (full access)                      │ │
│  │  3. Query UserPermission for user                         │ │
│  │  4. Validate required permissions                         │ │
│  │  5. Return UserPermissionResponse or 403                  │ │
│  └────────────────────────────────────────────────────────────┘ │
└─────────────────────────┬────────────────────────────────────────┘
                          │
                          ▼
┌──────────────────────────────────────────────────────────────────┐
│  ROUTE HANDLER (Controller)                                      │
│  File: app/routes/account.py                                     │
│  ┌────────────────────────────────────────────────────────────┐ │
│  │ @router.post("/", operation_id="createAccount")            │ │
│  │ async def create_account_route(                            │ │
│  │     payload: AccountCreate,  # Pydantic validation        │ │
│  │     user: User,              # From dependency             │ │
│  │     user_permission          # From dependency             │ │
│  │ ):                                                         │ │
│  │     # Call service layer                                   │ │
│  │     account = await create_account(payload, user)          │ │
│  │     return AccountCreateResponse(...)                      │ │
│  └────────────────────────────────────────────────────────────┘ │
└─────────────────────────┬────────────────────────────────────────┘
                          │
                          ▼
┌──────────────────────────────────────────────────────────────────┐
│  SERVICE LAYER (Business Logic)                                  │
│  File: app/services/account.py                                   │
│  ┌────────────────────────────────────────────────────────────┐ │
│  │ async def create_account(payload, current_user):           │ │
│  │     # 1. Guard clauses - validate business rules           │ │
│  │     if not current_user.org_id:                            │ │
│  │         raise MegapolisHTTPException(403, ...)             │ │
│  │                                                            │ │
│  │     # 2. Get request transaction                           │ │
│  │     db = get_request_transaction()                         │ │
│  │                                                            │ │
│  │     # 3. Complex validation (duplicate emails)             │ │
│  │     existing_contacts = await db.execute(...)              │ │
│  │     if existing_contacts:                                  │ │
│  │         raise MegapolisHTTPException(400, ...)             │ │
│  │                                                            │ │
│  │     # 4. Multi-step creation (Address -> Account ->        │ │
│  │     #    Primary Contact -> Secondary Contacts)            │ │
│  │     address = Address(...)                                 │ │
│  │     db.add(address)                                        │ │
│  │     await db.flush()  # Get address.id                     │ │
│  │                                                            │ │
│  │     account = Account(client_address_id=address.id, ...)   │ │
│  │     db.add(account)                                        │ │
│  │     await db.flush()                                       │ │
│  │                                                            │ │
│  │     primary_contact = Contact(account_id=account.id, ...)  │ │
│  │     db.add(primary_contact)                                │ │
│  │     await db.flush()                                       │ │
│  │                                                            │ │
│  │     account.primary_contact_id = primary_contact.id        │ │
│  │                                                            │ │
│  │     # 5. Logging                                           │ │
│  │     logger.info(f"Created account {account.account_id}")   │ │
│  │                                                            │ │
│  │     # 6. Return (middleware commits transaction)           │ │
│  │     return account                                         │ │
│  └────────────────────────────────────────────────────────────┘ │
└─────────────────────────┬────────────────────────────────────────┘
                          │
                          ▼
┌──────────────────────────────────────────────────────────────────┐
│  MODEL LAYER (Optional - for simple queries)                     │
│  File: app/models/account.py                                     │
│  ┌────────────────────────────────────────────────────────────┐ │
│  │ class Account(Base):                                       │ │
│  │     __tablename__ = "accounts"                             │ │
│  │     # Columns with Mapped[] types                          │ │
│  │     # Relationships                                        │ │
│  │                                                            │ │
│  │     @classmethod                                           │ │
│  │     async def get_by_id(cls, account_id):                  │ │
│  │         async with get_transaction() as db:                │ │
│  │             result = await db.execute(                     │ │
│  │                 select(cls).where(cls.id == account_id)    │ │
│  │             )                                              │ │
│  │             return result.scalar_one_or_none()             │ │
│  └────────────────────────────────────────────────────────────┘ │
└─────────────────────────┬────────────────────────────────────────┘
                          │
                          ▼
┌──────────────────────────────────────────────────────────────────┐
│  DATABASE (PostgreSQL)                                           │
│  - Async connection via psycopg 3                                │
│  - Connection pool (size 20, max_overflow 40)                    │
│  - All queries within single transaction                         │
│  - ACID guarantees                                               │
└─────────────────────────┬────────────────────────────────────────┘
                          │
                          ▼ Response bubbles back up
┌──────────────────────────────────────────────────────────────────┐
│  RESPONSE FLOW                                                   │
│  ┌────────────────────────────────────────────────────────────┐ │
│  │ 1. Service returns Account object                          │ │
│  │ 2. Route converts to AccountCreateResponse (Pydantic)      │ │
│  │ 3. FastAPI serializes to JSON                              │ │
│  │ 4. Middleware commits transaction                          │ │
│  │ 5. HTTP 201 Created response sent to client               │ │
│  └────────────────────────────────────────────────────────────┘ │
└──────────────────────────────────────────────────────────────────┘
```

### 2. Authentication Flow Diagram

```
┌──────────────┐                                  ┌──────────────┐
│   Frontend   │                                  │   Supabase   │
│  (React App) │                                  │     Auth     │
└──────┬───────┘                                  └──────┬───────┘
       │                                                 │
       │ 1. User signup/login                            │
       ├────────────────────────────────────────────────►│
       │                                                 │
       │ 2. Supabase JWT token                           │
       │◄────────────────────────────────────────────────┤
       │                                                 │
       │                                                 │
       │                                  ┌──────────────▼──────┐
       │ 3. POST /auth/verify_supabase_token             │
       │    Authorization: Bearer <supabase_jwt>         │
       ├────────────────────────────────►│   Megapolis  │
       │                                 │   Backend    │
       │                                 │              │
       │                                 │ 4. Verify    │
       │                                 │    token     │
       │                                 │    with      │
       │                                 │    Supabase  │
       │                                 ├──────────────┘
       │                                 │      │
       │                                 │ 5. Create/find
       │                                 │    user in DB
       │                                 │      │
       │                                 │ 6. Generate
       │                                 │    our JWT
       │                                 │    (30 days)
       │ 7. Response with app JWT        │
       │◄────────────────────────────────┤
       │    {                            │
       │      "token": "eyJ...",          │
       │      "user": {...}               │
       │    }                            │
       │                                 │
       │ 8. Store token in localStorage  │
       │                                 │
       │                                 │
       │ 9. All API requests             │
       │    Authorization: Bearer <app_jwt>
       ├────────────────────────────────►│
       │                                 │
       │                                 │ 10. Verify JWT
       │                                 │     signature
       │                                 │     & expiry
       │                                 │
       │ 11. Protected resource data     │
       │◄────────────────────────────────┤
       │                                 │
       │                                 │
       │ On 401 Unauthorized:            │
       │ - Clear localStorage            │
       │ - Redirect to login             │
       │                                 │
```

### 3. Permission System Flow

```
┌────────────────────────────────────────────────────────────────┐
│  User makes request to protected endpoint                      │
│  POST /accounts/  (requires accounts: view, edit)              │
└──────────────────────────┬─────────────────────────────────────┘
                           │
                           ▼
┌──────────────────────────────────────────────────────────────┐
│  Dependency: get_current_user(request)                        │
│  - Extract & verify JWT                                       │
│  - Load User from DB                                          │
│  - Returns: User object                                       │
└──────────────────────────┬───────────────────────────────────┘
                           │
                           ▼
┌──────────────────────────────────────────────────────────────┐
│  Dependency: get_user_permission({"accounts": ["view", "edit"]})│
│  ┌──────────────────────────────────────────────────────────┐│
│  │ 1. Check if user is organization owner                   ││
│  │    If yes → grant full permissions, skip checks          ││
│  │                                                          ││
│  │ 2. Query UserPermission table                            ││
│  │    SELECT * FROM user_permission WHERE userid = ?        ││
│  │                                                          ││
│  │ 3. If no permissions found:                              ││
│  │    → Raise 403 Forbidden                                 ││
│  │                                                          ││
│  │ 4. Check each required resource:                         ││
│  │    required_permissions = {                              ││
│  │      "accounts": ["view", "edit"]                        ││
│  │    }                                                     ││
│  │                                                          ││
│  │    user_permissions.accounts = ["view", "edit"]          ││
│  │                                                          ││
│  │    missing = [a for a in required if a not in user_perms]││
│  │                                                          ││
│  │    If missing:                                           ││
│  │      → Raise 403 with details                            ││
│  │                                                          ││
│  │ 5. Return UserPermissionResponse                         ││
│  └──────────────────────────────────────────────────────────┘│
└──────────────────────────┬───────────────────────────────────┘
                           │
                           ▼
┌──────────────────────────────────────────────────────────────┐
│  Route handler executes                                       │
│  - User has been authenticated                                │
│  - Permissions have been verified                             │
│  - Business logic proceeds                                    │
└──────────────────────────────────────────────────────────────┘

Permission Levels:
┌──────────────────────┐
│ Organization Owner   │ → Full access to all resources
└──────────────────────┘
           ▼
┌──────────────────────┐
│ User with Permissions│ → Granular access based on UserPermission
│                      │   - accounts: [view, edit]
│                      │   - opportunities: [view]
│                      │   - proposals: [view, edit]
└──────────────────────┘
           ▼
┌──────────────────────┐
│ User without Perms   │ → 403 Forbidden
└──────────────────────┘
```

---

## Database Schema

### Entity Relationship Diagram

```
┌─────────────────┐
│  organizations  │
├─────────────────┤
│ id (PK, UUID)   │──┐
│ owner_id (FK)   │  │
│ name            │  │
│ website         │  │
│ address_id (FK) │  │
│ contact_id (FK) │  │
│ formbricks_org_id│ │
│ created_at      │  │
└─────────────────┘  │
         │           │
         │ 1:N       │
         ▼           │
┌─────────────────┐  │
│     users       │  │
├─────────────────┤  │
│ id (PK, UUID)   │  │
│ email           │  │
│ org_id (FK)     │◄─┘
│ role            │
│ formbricks_user_id│
└─────────────────┘
         │
         │ 1:1
         ▼
┌─────────────────┐
│user_permission  │
├─────────────────┤
│ userid (PK, FK) │
│ accounts        │ → Array: ["view", "edit"]
│ opportunities   │ → Array: ["view"]
│ proposals       │ → Array: ["view", "edit"]
└─────────────────┘

┌─────────────────┐
│    accounts     │
├─────────────────┤
│ account_id (PK) │──┐
│ client_name     │  │
│ client_type     │  │ (tier_1, tier_2, tier_3)
│ market_sector   │  │
│ company_website │  │
│ total_value     │  │
│ ai_health_score │  │
│ last_contact    │  │
│ org_id (FK)     │  │
│ client_address_id│ │
│ primary_contact_id│ │
│ created_at      │  │
│ updated_at      │  │
└─────────────────┘  │
         │           │
         │ 1:N       │
         ├───────────┘
         │
         ├─────────► ┌─────────────────┐
         │           │   contacts      │
         │           ├─────────────────┤
         │           │ id (PK, UUID)   │
         │           │ account_id (FK) │
         │           │ org_id (FK)     │
         │           │ name            │
         │           │ email (unique)  │
         │           │ phone           │
         │           │ designation     │
         │           └─────────────────┘
         │
         ├─────────► ┌─────────────────┐
         │           │ account_notes   │
         │           ├─────────────────┤
         │           │ id (PK, UUID)   │
         │           │ account_id (FK) │
         │           │ content         │
         │           │ created_at      │
         │           │ updated_at      │
         │           └─────────────────┘
         │
         └─────────► ┌─────────────────┐
                     │account_documents│